#!/usr/bin/env python

# Logaar - web application
#
# Copyright (C) 2011 Federico Ceratto
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from beaker.middleware import SessionMiddleware
import bottle
from bottle import abort, route, static_file, run, view, request
from bottle import debug as bottle_debug
from bottle import HTTPResponse, HTTPError

from collections import defaultdict
from datetime import datetime
from pymongo import has_c, ASCENDING, DESCENDING #TODO: remove this
from sys import exit
from time import time, sleep, localtime

from collector import Collector
from confreader import ConfReader
from monitor import stat_generator
from parser import Parser
#import mailer
from core import Alert, Users, clean
from dbconnector import DB
#from flmap import draw_png_map, draw_svg_map
#from flutils import flag, extract_all, get_rss_channels

import json
from pymongo import json_util
import re

from argparse import ArgumentParser


import logging
logging.debug('starting')
log = logging.getLogger(__name__)


db = None   # global db connection
processes = {} # non-webapp processes
stats = dict(
    collector_series = [], # collected logs per second list
    parser_series = [],  # parsed logs per second list
)

def say(s, level=None):
        print s

def ack(s=None):
    """Acknowledge successful processing and returns ajax confirmation."""
    if s:
        say(s, level="success")
    return {'ok': True}

def ret_warn(s=None):
    """Generate warn message and returns ajax 'ok: False'."""
    if s:
        say(s, level="warning")
    return {'ok': False}

def ret_alert(s=None):
    """Generate alert message and returns ajax 'ok: False'."""
    if s:
        say(s, level="alert")
    return {'ok': False}

def pg(name, default=''):
    """Retrieve an element from a POST request"""
    s = request.POST.get(name, default)[:64]
    return clean(s).strip()

def pg_list(name, default=''):
    """Retrieve a serialized (comma-separated) list from a POST request.
    Duplicated elements are removed"""
    # FIXME: a hostgroup containing hundreds of hosts may exceed POST size
    s = request.POST.get(name, default)
    li = clean(s).strip().split(',')
    return list(set(li))

def int_pg(name, default=None):
    """Retrieve an element from a POST request and returns it as an integer"""
    v = request.POST.get(name, default)
    if v == '':
        return None
    try:
        return int(v)
    except:
        raise Exception, "Expected int as POST parameter, got string: '%s'." % v

def pcheckbox(name):
    """Retrieve a checkbox status from a POST request generated by serializeArray() and returns '0' or '1' """
    if name in request.POST:
        return '1'
    return '0'

def rg(name, default=None, caster=str):
    """Get a parameter from the GET request"""
    if name in request.GET:
        return caster(request.GET[name])
    return default

# # #  web services  # # #


# #  authentication  # #

def _require(role='readonly'):
    """Ensure the user has the required role (or higher).
    Order is: admin > editor > readonly
    """
    m = {'admin': 15, 'editor': 10, 'readonly': 5}
    s = bottle.request.environ.get('beaker.session')
    if not s:
        say("User needs to be authenticated.", level="warning")
        #TODO: not really explanatory in a multiuser session.
        raise Alert, "User needs to be authenticated."
    myrole = s.get('role', None)
    if not myrole:
        raise Alert, "User needs to be authenticated."
    if m[myrole] >= m[role]:
        return
    say("An account with '%s' level or higher is required." % repr(role))
    raise Exception

@bottle.route('/login', method='POST')
def login():
    """ """
    s = bottle.request.environ.get('beaker.session')
    if 'username' in s:  # user is authenticated <--> username is set
        say("Already logged in as \"%s\"." % s['username'])
        return {'logged_in': True}
    user = pg('user', '')
    pwd = pg('pwd', '')
    try:
        users.validate(user, pwd)
        role = users._users[user][0]
        say("User %s with role %s logged in." % (user, role), level="success")
        s['username'] = user
        s['role'] = role
        s = bottle.request.environ.get('beaker.session')
        s.save()
        bottle.redirect('')
    except (Alert, AssertionError), e:
        say("Login denied for \"%s\": %s" % (user, e), level="warning")
        log.debug("Login denied for \"%s\": %s" % (user, e))
        bottle.redirect('')

@bottle.route('/logout')
def logout():
    s = bottle.request.environ.get('beaker.session')
    u = s.get('username', None)
    if u:
        say('User %s logged out.' % u)
    s.delete()
    bottle.redirect('')

# end of authentication

@bottle.route('/')
@view('index')
def index():
    s = bottle.request.environ.get('beaker.session')
    logged_in = True if s and 'username' in s else False

    try:
        title = conf.title
    except:
        title = 'test'
    return dict(msg=None, title=title, logged_in=logged_in)

# #  tables interaction  # #
#
# GETs are used to list all table contents
# POSTs are used to make changes or to populate editing forms
# POST "verbs" are sent using the "action" key, and the "rid" key
# specifies the target:
#   - delete
#   - moveup/movedown/enable/disable   see ruleset()
#   - edit: updates an element if rid is not null, otherwise creates
#             a new one


@bottle.route('/logs')
@view('logs')
def logs():
    _require()
    keys = ('date', 'level', 'program', 'pid', 'message', 'score', 'tags')
    return dict(keys=keys, callback='dlogs')

@bottle.get('/dlogs')
def dlogs():
    """Serve dynamic logs table"""
    logs_cols = ('date', 'level', 'program', 'pid', 'msg', 'score', 'tags')

    skip = rg('iDisplayStart', caster=int, default=10)
    sort_on = rg('iSortCol_0', caster=int, default=0)
    sort_on = logs_cols[sort_on]
    sort_dir = rg('sSortDir_0', default='desc')
    free_search = rg('sSearch', default='a')
    limit = rg('iDisplayLength', caster=int, default=10)
    sEcho = rg('sEcho', caster=int)

    aaData, displayed,  total = db.search(
        db.logs,
        skip=skip,
        sort_on=sort_on,
        sort_dir=sort_dir,
        free_search=free_search,
        limit=limit,
        keys=logs_cols,
        search_key='msg',
    )

    d = {
        'iTotalRecords': total,
        'iTotalDisplayRecords': displayed,
        'sEcho': sEcho,
        'aaData': aaData
    }
    return json.dumps(d, default=json_util.default)


@bottle.route('/incoming')
@view('logs')
def incoming():
    _require()
    keys = ('date', 'message')
    return dict(keys=keys, callback='dincoming')

@bottle.get('/dincoming')
def dincoming():
    """Serve dynamic logs table"""
    keys = ('date', 'msg')
    coll = db.incoming

    skip = rg('iDisplayStart', caster=int, default=10)
    sort_on = rg('iSortCol_0', caster=int, default=0)
    sort_on = keys[sort_on]
    sort_dir = rg('sSortDir_0', default='desc')
    sort_dir = DESCENDING if sort_dir == 'desc' else ASCENDING
    free_search = rg('sSearch', default='a')
    lim = rg('iDisplayLength', caster=int, default=10)
    sEcho = rg('sEcho', caster=int)

    if free_search:
        regexp = re.compile(free_search, re.IGNORECASE)
        ru = coll.find({'rule': regexp, 'processed': None}, limit=lim, skip=skip).sort(sort_on, sort_dir)
    else:
        ru = coll.find({'processed': None}, limit=lim, skip=skip).sort(sort_on, sort_dir)

    aaData =  [[str(r.get(k, '')) for k in keys] for r in ru]
    print repr(aaData)
    d = {
        'iTotalRecords': coll.count(),
        'iTotalDisplayRecords': ru.count(),
        'sEcho': sEcho,
        'aaData': aaData
    }
    return json.dumps(d, default=json_util.default)


@bottle.route('/rules')
@view('rules')
def rules():
    _require()
    rules = db.rules.find()
    keys =  (
        'id',
        'program' ,
        'son' ,
        'author' ,
        'modify_date' ,
        'score',
        'revision' ,
        'rule' ,
        'level' ,
        'host' ,
        'rule_type' ,
        'event_type'
    )
    return dict(rules=rules, keys=keys)

#Type   Name    Info
#int    iDisplayStart   Display start point
#int    iDisplayLength  Number of records to display
#int    iColumns    Number of columns being displayed (useful for getting individual column search info)
#string sSearch Global search field
#boolean    bEscapeRegex    Global search is regex or not
#boolean    bSortable_(int) Indicator for if a column is flagged as sortable or not on the client-side
#boolean    bSearchable_(int)   Indicator for if a column is flagged as searchable or not on the client-side
#string sSearch_(int)   Individual column filter
#boolean    bEscapeRegex_(int)  Individual column filter is regex or not
#int    iSortingCols    Number of columns to sort on
#int    iSortCol_(int)  Column being sorted on (you will need to decode this number for your database)
#string sSortDir_(int)  Direction to be sorted - "desc" or "asc". Note that the prefix for this variable is wrong in 1.5.x where iSortDir_(int) was used)
#string sEcho   Information for DataTables to use for rendering






#from json import JSONEncoder
#from pymongo.objectid import ObjectId
#
#class MongoEncoder(JSONEncoder):
#    def _iterencode(self, o, markers=None):
#        if isinstance(o, ObjectId):
#            return """ObjectId("%s")""" % str(o)
#        else:
#            return JSONEncoder._iterencode(self, o, markers)

rules_cols =  (
    'id',
    'program' ,
    'son' ,
    'author' ,
    'modify_date' ,
    'score',
    'revision' ,
    'rule' ,
    'level' ,
    'host' ,
    'rule_type' ,
    'event_type'
)

@bottle.get('/drules')
def drules():

    skip = rg('iDisplayStart', caster=int, default=10)
    sort_on = rg('iSortCol_0', caster=int, default=0)
    sort_on = rules_cols[sort_on]
    sort_dir = rg('sSortDir_0', default='desc')
    free_search = rg('sSearch', default=None)
    limit = rg('iDisplayLength', caster=int, default=10)
    sEcho = rg('sEcho', caster=int)

    aaData, displayed,  total = db.search(
        db.rules,
        skip=skip,
        sort_on=sort_on,
        sort_dir=sort_dir,
        free_search=free_search,
        limit=limit,
        keys=rules_cols
    )

    d = {
        'iTotalRecords': total,
        'iTotalDisplayRecords': displayed,
        'sEcho': sEcho,
        'aaData': aaData
    }
    return json.dumps(d, default=json_util.default)


@bottle.route('/rules')
@view('rules')
def rules():
    _require()
    rules = db.rules.find()
    keys =  (
        'id',
        'program' ,
        'son' ,
        'author' ,
        'modify_date' ,
        'score',
        'revision' ,
        'rule' ,
        'level' ,
        'host' ,
        'rule_type' ,
        'event_type'
    )
    return dict(rules=rules, keys=keys)

class SparseDict(dict):
    def __missing__(self, key):
        return 0

def timed(func):
  def wrapper(*args, **kw):
        t = time()
        res = func(*args, **kw)
        print '%s ran in %0.3f ms' % (func.func_name, (time() - t)*1000)
        return res
  return wrapper

@bottle.route('/stats_top_talkers')
@view('stats_top_talkers')
@timed
def top_talkers():
    """Generate a sorted list of most chatty hosts"""
    #FIXME: use hosts, not program
    s = db.logs.group({'program': 1},None, {'count': 0},'function(obj,out) { out.count++; }')
    toplist = ((p['count'], p['program']) for p in s)
    return {'top_talkers': sorted(toplist, reverse=True)[:10]}

@bottle.route('/stats_top_programs')
@view('stats_top_programs')
@timed
def top_programs():
    """Generate a sorted list of most chatty programs"""
    s = db.logs.group({'program': 1},None, {'count': 0},'function(obj,out) { out.count++; }')
    toplist = ((p['count'], p['program']) for p in s)
    return {'top_programs': sorted(toplist, reverse=True)[:10]}

@bottle.route('/stats_traffic')
@view('stats_traffic')
@timed
def stats_traffic():

    s = db.logs.inline_map_reduce(
        """
        var created_at_minute =
            this.date.substring(0,15);
        emit(created_at_minute, {count: 1});""",

        """
        function(key, values) {
                 var total = 0;
                 for(var i = 0; i < values.length; i++) { total += values[i].count; }
                 return {key: key, count: total};
        }""",
    )

    traffic = tuple(i['value']['count'] for i in s)
    traffic = traffic[-60:]

    d = bdict(
        series = enumerate(traffic),
        ymin=min(traffic),
        ymax=max(traffic),
        xmin=0,
        xmax=3,
   )
    return {'traffic': d}


@bottle.route('/stats')
@view('stats')
def statistics():
    return {}

@bottle.route('/stats2')
def statistics():
    global stats
    return repr(stats)

@bottle.route('/manage')
@view('manage')
def manage():
    global processes
    return dict(
        collector = processes['collector'].shared,
        parser = processes['parser'].shared
    )

@bottle.route('/shutdown')
def shutdown():
    global processes
    log.info("Shutting down processes.")
    for t in processes.itervalues():
        t.stop()
    log.info("Exiting.")
    exit(1)



class bdict(dict):
    """Trivial dict that maps values to attributes"""
    def __getattr__(self, item):
        return self.__getitem__(item)


# serving static files

@bottle.route('/static/:filename#[-a-zA-Z0-9_\.?\/?]+#')
def static(filename):
    _require()
    bottle.response.headers['Cache-Control'] = 'max-age=3600, public'
    if filename == '/jquery-ui.js':
        return static_file('jquery-ui/jquery-ui.js',
            '/usr/share/javascript/') #TODO: support other distros

    elif filename == 'jquery.min.js':
        return static_file('jquery/jquery.min.js', '/usr/share/javascript/')

    elif filename == 'jquery-ui.custom.css': #TODO: support version change
        return static_file('jquery-ui/css/smoothness/jquery-ui-1.7.2.custom.css',
            '/usr/share/javascript/')

    elif filename == 'jquery.mousewheel.min.js':
        return static_file(filename, '/usr/share/javascript/jquery-mousewheel/')

    else:
        return static_file(filename, 'static')


@bottle.route('/favicon.ico')
def favicon():
    static_file('favicon.ico', 'static')


# end of web services


# statistics thread
from threading import Timer

def stat_generator():
    """Monitor processes, generate statistics"""
    global stats
    global processes

    # access shared memory, fetch and reset counters
    recv = processes['collector'].shared['received']
    processes['collector'].shared['received'] = 0
    stats['collector_series'].append(recv)
    if len(stats['collector_series']) > 20:
        stats['collector_series'].pop(0)
#    print "Runtime: %d, processed logs: %d ps, successful: %d ps" % \
#        (time() - stats['start_time'], stats['processed'], stats['success'])
#    stats['processed'] = 0
#    stats['success'] = 0
    Timer(1, stat_generator).start()



# main

def main():
    global conf
    global db
    global processes

    parser = ArgumentParser(description='Logaar daemon')
    parser.add_argument('-d', '--debug', action='store_true', help='debug mode')
    parser.add_argument('-c', '--cf',  nargs='?',
        default = 'logaar.ini', help='configuration file')
    parser.add_argument('-r', '--repodir',  nargs='?',
        help='repository directory')
    args = parser.parse_args()

    try:
        conf = ConfReader(fn=args.cf)
    except Exception, e:
        log.error("Exception %s while reading configuration file '%s'" % (e, args.cf))
        exit(1)

    if args.repodir:
        conf.data_dir = args.repodir

    # Setting up DB connectivity
    try:
        db = DB()
    except Exception, e:
        log.error("Unable to setup connection to the database: %s" % e)
        exit(1)
    #TODO DB(host=...)

    from os import getpid
    def debug(s):
        print 'webapp', getpid(), s

    # Start non-webapp processes
    debug("starting parser...")
    processes['parser'] = Parser(conf)
    processes['parser'].start()

    debug("starting collector...")
    processes['collector'] = Collector(conf)
    processes['collector'].start()

    debug("starting monitor...")
#    stat_generator()
    Timer(1, stat_generator).start()

    # logging

    if args.debug:
        debug_mode = True
#        log.basicConfig(level=log.DEBUG,
#                        format='%(asctime)s %(levelname)-8s %(message)s',
#                        datefmt='%a, %d %b %Y %H:%M:%S')
        log.debug("Debug mode")
        log.debug("Configuration file: '%s'" % args.cf)
        bottle.debug(True)
        say("Logaar started in debug mode.", level="success")
        bottle_debug(True)
        reload = True
    else:
        debug_mode = False
#        log.basicConfig(level=log.INFO,
#                    format='%(asctime)s %(levelname)-8s %(message)s',
#                    datefmt='%a, %d %b %Y %H:%M:%S',
#                    filename=conf.logfile,
#                    filemode='w')
        reload = False
        say("Logaar started.", level="success")

    globals()['users'] = Users(d=conf.data_dir)

    session_opts = {
        'session.type': 'cookie',
        'session.validate_key': True,
    }
    app = bottle.default_app()
    app = SessionMiddleware(app, session_opts)

    run(app=app, host=conf.listen_address, port=conf.listen_port, reloader=reload)

    log.info("Shutting down processes.")

    for name in ('parser', 'collector'):
        processes[name].stop()

    log.info("Exiting.")





if __name__ == "__main__":
        main()

